# 컴퓨터 알고리즘 기초 | T 아카데미

## 1. 컴퓨터 알고리즘의 수행시간 분석
- 수행시간은 입력으로 크기가 커지면 커질수록 시간이 많이 걸린다.
    - 예: 10개의 키를 정렬하는 시간이 100개의 키를 정렬하는 시간보다 길다.

- 수행시간은 <b>입력 크기 n에 대한 함수로 표현<b>한다.
    - 예: T(n) -> n에 대한 다항식에서 최고차 항만을 고려한다.

## 2. 점근적 표기법.
1) BIG-O 표기
2) 오메카 표기
3) 세타 표기
- cf) g(n): 기준 <-> f(n): 구할려고 하는 함수


### 1) BIG-O 표기법
- O(g(n)) = {f(n): n >= n0 인 모든 n에 대해 0 <= f(n) <= cg(n)를 만족하는 양수 상수 c와 n0가 존재}

- n0 보다 오른쪽에 있는 모든 n에 대해서 함수 f(n)의 값은 cg(n)과 같거나 아래쪽에 있다. => upper bound, 상한

===> f(n)이 아래에 있다는 것은 아무리 느려도 cg(n)보다 빠르다

<img src="./image/big-o.jpg">

### 2) Ω 표기법
- Ω(g(n)) = {f(n): n >= 0 인 모든 n에 대해 0 <= cg(n)<= f(n)을 만족하는 양수 상수 c와 n0가 존재}

- n0 보다 오른쪽에 있는 모든 n에 대해서 함수 f(n)의 값은 cg(n)과 같거나 위쪽에 있다. => lower bound, 하한
===> f(n)이 위에 있다는 것은 f(n)이 느리다는 것이다.
===> f(n)이 아무리 빨라져도 cg(n)보다 느리다.

<img src="./image/오메가.jpg">

### 3) θ 표기법 => BIG-O + Ω = θ 표기법
- θ(g(n)) = {f(n): n>= n0 인 모든 n에 대해 0<=cg(n)<=f(n)<=c1g(n)을 만족하는 양수 상수 c1c2와 n0가 존재}

- n0 보다 오른쪽에 있는 모든 n에 대해서 함수 f(n)의 값은 c1g(n)과 같거나 위쪽에 있고, c2g(n)과 같거나 아래쪽에 있다. => tight bound, 점근적 상한 및 하한

===> 아무리 f(n)이 빨라도 c1g(n)보다 느리고, 아무리 f(n)이 느려도 c2g(n)이 빠르다.

<img src="./image/세타.jpg">



